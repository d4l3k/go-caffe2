// Code generated by protoc-gen-go. DO NOT EDIT.
// source: caffe2/proto/caffe2.proto

package caffe2pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// DeviceType that Caffe2 currently supports.
// Note: if you add a device type, make sure you add the corresponding device
// line in the DeviceTypeName() function in caffe2/utils/proto_utils.cc
// and update c10/DeviceType.h
type DeviceTypeProto int32

const (
	DeviceTypeProto_PROTO_CPU    DeviceTypeProto = 0
	DeviceTypeProto_PROTO_CUDA   DeviceTypeProto = 1
	DeviceTypeProto_PROTO_MKLDNN DeviceTypeProto = 2
	DeviceTypeProto_PROTO_OPENGL DeviceTypeProto = 3
	DeviceTypeProto_PROTO_OPENCL DeviceTypeProto = 4
	DeviceTypeProto_PROTO_IDEEP  DeviceTypeProto = 5
	DeviceTypeProto_PROTO_HIP    DeviceTypeProto = 6
	DeviceTypeProto_PROTO_FPGA   DeviceTypeProto = 7
	// Change the following number if you add more devices in the code.
	DeviceTypeProto_PROTO_COMPILE_TIME_MAX_DEVICE_TYPES DeviceTypeProto = 8
	DeviceTypeProto_PROTO_ONLY_FOR_TEST                 DeviceTypeProto = 20901
)

var DeviceTypeProto_name = map[int32]string{
	0:     "PROTO_CPU",
	1:     "PROTO_CUDA",
	2:     "PROTO_MKLDNN",
	3:     "PROTO_OPENGL",
	4:     "PROTO_OPENCL",
	5:     "PROTO_IDEEP",
	6:     "PROTO_HIP",
	7:     "PROTO_FPGA",
	8:     "PROTO_COMPILE_TIME_MAX_DEVICE_TYPES",
	20901: "PROTO_ONLY_FOR_TEST",
}
var DeviceTypeProto_value = map[string]int32{
	"PROTO_CPU":                           0,
	"PROTO_CUDA":                          1,
	"PROTO_MKLDNN":                        2,
	"PROTO_OPENGL":                        3,
	"PROTO_OPENCL":                        4,
	"PROTO_IDEEP":                         5,
	"PROTO_HIP":                           6,
	"PROTO_FPGA":                          7,
	"PROTO_COMPILE_TIME_MAX_DEVICE_TYPES": 8,
	"PROTO_ONLY_FOR_TEST":                 20901,
}

func (x DeviceTypeProto) Enum() *DeviceTypeProto {
	p := new(DeviceTypeProto)
	*p = x
	return p
}
func (x DeviceTypeProto) String() string {
	return proto.EnumName(DeviceTypeProto_name, int32(x))
}
func (x *DeviceTypeProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DeviceTypeProto_value, data, "DeviceTypeProto")
	if err != nil {
		return err
	}
	*x = DeviceTypeProto(value)
	return nil
}
func (DeviceTypeProto) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

// type of the external storage type, can be the following:
type ExternalDataProto_SourceType int32

const (
	// the container defined in torch/csrc/jit/serialization.h is used,
	// and record_id is the tag to help the runtime identify the data
	// this type of storage is set as DEFAULT and recommended for external
	// data storage
	ExternalDataProto_INLINE_CONTAINER ExternalDataProto_SourceType = 0
	// use external file to store the data, and record_id is the POSIX relative path
	// to the file. this (simple) file is only for the data, and the data is stored
	// as little endian in the file
	ExternalDataProto_SIMPLE_FILE ExternalDataProto_SourceType = 1
)

var ExternalDataProto_SourceType_name = map[int32]string{
	0: "INLINE_CONTAINER",
	1: "SIMPLE_FILE",
}
var ExternalDataProto_SourceType_value = map[string]int32{
	"INLINE_CONTAINER": 0,
	"SIMPLE_FILE":      1,
}

func (x ExternalDataProto_SourceType) Enum() *ExternalDataProto_SourceType {
	p := new(ExternalDataProto_SourceType)
	*p = x
	return p
}
func (x ExternalDataProto_SourceType) String() string {
	return proto.EnumName(ExternalDataProto_SourceType_name, int32(x))
}
func (x *ExternalDataProto_SourceType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExternalDataProto_SourceType_value, data, "ExternalDataProto_SourceType")
	if err != nil {
		return err
	}
	*x = ExternalDataProto_SourceType(value)
	return nil
}
func (ExternalDataProto_SourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{0, 0}
}

// Data type
type TensorProto_DataType int32

const (
	TensorProto_UNDEFINED TensorProto_DataType = 0
	// Basic types
	TensorProto_FLOAT  TensorProto_DataType = 1
	TensorProto_INT32  TensorProto_DataType = 2
	TensorProto_BYTE   TensorProto_DataType = 3
	TensorProto_STRING TensorProto_DataType = 4
	// Less-commonly used data types
	TensorProto_BOOL    TensorProto_DataType = 5
	TensorProto_UINT8   TensorProto_DataType = 6
	TensorProto_INT8    TensorProto_DataType = 7
	TensorProto_UINT16  TensorProto_DataType = 8
	TensorProto_INT16   TensorProto_DataType = 9
	TensorProto_INT64   TensorProto_DataType = 10
	TensorProto_FLOAT16 TensorProto_DataType = 12
	TensorProto_DOUBLE  TensorProto_DataType = 13
)

var TensorProto_DataType_name = map[int32]string{
	0:  "UNDEFINED",
	1:  "FLOAT",
	2:  "INT32",
	3:  "BYTE",
	4:  "STRING",
	5:  "BOOL",
	6:  "UINT8",
	7:  "INT8",
	8:  "UINT16",
	9:  "INT16",
	10: "INT64",
	12: "FLOAT16",
	13: "DOUBLE",
}
var TensorProto_DataType_value = map[string]int32{
	"UNDEFINED": 0,
	"FLOAT":     1,
	"INT32":     2,
	"BYTE":      3,
	"STRING":    4,
	"BOOL":      5,
	"UINT8":     6,
	"INT8":      7,
	"UINT16":    8,
	"INT16":     9,
	"INT64":     10,
	"FLOAT16":   12,
	"DOUBLE":    13,
}

func (x TensorProto_DataType) Enum() *TensorProto_DataType {
	p := new(TensorProto_DataType)
	*p = x
	return p
}
func (x TensorProto_DataType) String() string {
	return proto.EnumName(TensorProto_DataType_name, int32(x))
}
func (x *TensorProto_DataType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TensorProto_DataType_value, data, "TensorProto_DataType")
	if err != nil {
		return err
	}
	*x = TensorProto_DataType(value)
	return nil
}
func (TensorProto_DataType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{1, 0} }

// data storage
type TensorProto_StorageType int32

const (
	// the content is stored in typed field, for example, if the data_type is
	// FLOAT, float_data is used to store the content.
	TensorProto_TYPED TensorProto_StorageType = 1
	// the content is serialized in field raw_data as little-endian
	TensorProto_RAW TensorProto_StorageType = 2
	// the pointer to the content is stored in field external_data
	// the content is serialized as little-endian
	TensorProto_EXTERNAL TensorProto_StorageType = 3
	// When StorageType is NO_CONTENT, we use TensorProto to store only type
	// and shape information. Reuse TensorProto to store type and shape
	// because we can just have one proto, not having another ValueInfoProto
	TensorProto_NO_CONTENT TensorProto_StorageType = 4
)

var TensorProto_StorageType_name = map[int32]string{
	1: "TYPED",
	2: "RAW",
	3: "EXTERNAL",
	4: "NO_CONTENT",
}
var TensorProto_StorageType_value = map[string]int32{
	"TYPED":      1,
	"RAW":        2,
	"EXTERNAL":   3,
	"NO_CONTENT": 4,
}

func (x TensorProto_StorageType) Enum() *TensorProto_StorageType {
	p := new(TensorProto_StorageType)
	*p = x
	return p
}
func (x TensorProto_StorageType) String() string {
	return proto.EnumName(TensorProto_StorageType_name, int32(x))
}
func (x *TensorProto_StorageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TensorProto_StorageType_value, data, "TensorProto_StorageType")
	if err != nil {
		return err
	}
	*x = TensorProto_StorageType(value)
	return nil
}
func (TensorProto_StorageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{1, 1} }

// ExternalDataProto stores the pointer to the content of TensorProto
// the content are stored in the raw format as little endian
type ExternalDataProto struct {
	SourceType *ExternalDataProto_SourceType `protobuf:"varint,1,opt,name=source_type,json=sourceType,enum=caffe2.ExternalDataProto_SourceType,def=0" json:"source_type,omitempty"`
	// used together with type
	RecordId *string `protobuf:"bytes,2,opt,name=record_id,json=recordId" json:"record_id,omitempty"`
	// the size of the entire record (in bytes)
	RecordSize *uint64 `protobuf:"varint,5,opt,name=record_size,json=recordSize" json:"record_size,omitempty"`
	// the offset of the starting point, the content may be shared between
	// multiple tensors
	Offset *int64 `protobuf:"varint,3,opt,name=offset,def=0" json:"offset,omitempty"`
	// the strides of the content
	Strides          []int64 `protobuf:"varint,4,rep,name=strides" json:"strides,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ExternalDataProto) Reset()                    { *m = ExternalDataProto{} }
func (m *ExternalDataProto) String() string            { return proto.CompactTextString(m) }
func (*ExternalDataProto) ProtoMessage()               {}
func (*ExternalDataProto) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

const Default_ExternalDataProto_SourceType ExternalDataProto_SourceType = ExternalDataProto_INLINE_CONTAINER
const Default_ExternalDataProto_Offset int64 = 0

func (m *ExternalDataProto) GetSourceType() ExternalDataProto_SourceType {
	if m != nil && m.SourceType != nil {
		return *m.SourceType
	}
	return Default_ExternalDataProto_SourceType
}

func (m *ExternalDataProto) GetRecordId() string {
	if m != nil && m.RecordId != nil {
		return *m.RecordId
	}
	return ""
}

func (m *ExternalDataProto) GetRecordSize() uint64 {
	if m != nil && m.RecordSize != nil {
		return *m.RecordSize
	}
	return 0
}

func (m *ExternalDataProto) GetOffset() int64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return Default_ExternalDataProto_Offset
}

func (m *ExternalDataProto) GetStrides() []int64 {
	if m != nil {
		return m.Strides
	}
	return nil
}

// TensorProto stores serialized Tensor objects.
type TensorProto struct {
	// The dimensions in the tensor.
	Dims        []int64                  `protobuf:"varint,1,rep,name=dims" json:"dims,omitempty"`
	DataType    *TensorProto_DataType    `protobuf:"varint,2,opt,name=data_type,json=dataType,enum=caffe2.TensorProto_DataType,def=1" json:"data_type,omitempty"`
	StorageType *TensorProto_StorageType `protobuf:"varint,12,opt,name=storage_type,json=storageType,enum=caffe2.TensorProto_StorageType,def=1" json:"storage_type,omitempty"`
	// For float
	FloatData []float32 `protobuf:"fixed32,3,rep,packed,name=float_data,json=floatData" json:"float_data,omitempty"`
	// For int32, uint8, int8, uint16, int16, bool, and float16
	// Note about float16: in storage we will basically convert float16 byte-wise
	// to unsigned short and then store them in the int32_data field.
	Int32Data []int32 `protobuf:"varint,4,rep,packed,name=int32_data,json=int32Data" json:"int32_data,omitempty"`
	// For bytes
	ByteData []byte `protobuf:"bytes,5,opt,name=byte_data,json=byteData" json:"byte_data,omitempty"`
	// For strings
	StringData [][]byte `protobuf:"bytes,6,rep,name=string_data,json=stringData" json:"string_data,omitempty"`
	// For double
	DoubleData []float64 `protobuf:"fixed64,9,rep,packed,name=double_data,json=doubleData" json:"double_data,omitempty"`
	// For int64
	Int64Data []int64 `protobuf:"varint,10,rep,packed,name=int64_data,json=int64Data" json:"int64_data,omitempty"`
	// store the raw data, contents are serialized as little-endian
	RawData []byte `protobuf:"bytes,13,opt,name=raw_data,json=rawData" json:"raw_data,omitempty"`
	// store the pointer to the data
	ExternalData *ExternalDataProto `protobuf:"bytes,14,opt,name=external_data,json=externalData" json:"external_data,omitempty"`
	// Optionally, a name for the tensor.
	Name *string `protobuf:"bytes,7,opt,name=name" json:"name,omitempty"`
	// Optionally, a TensorProto can contain the details about the device that
	// it was serialized from. This is useful in cases like snapshotting a whole
	// workspace in a multi-GPU environment.
	DeviceDetail     *DeviceOption        `protobuf:"bytes,8,opt,name=device_detail,json=deviceDetail" json:"device_detail,omitempty"`
	Segment          *TensorProto_Segment `protobuf:"bytes,11,opt,name=segment" json:"segment,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *TensorProto) Reset()                    { *m = TensorProto{} }
func (m *TensorProto) String() string            { return proto.CompactTextString(m) }
func (*TensorProto) ProtoMessage()               {}
func (*TensorProto) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

const Default_TensorProto_DataType TensorProto_DataType = TensorProto_FLOAT
const Default_TensorProto_StorageType TensorProto_StorageType = TensorProto_TYPED

func (m *TensorProto) GetDims() []int64 {
	if m != nil {
		return m.Dims
	}
	return nil
}

func (m *TensorProto) GetDataType() TensorProto_DataType {
	if m != nil && m.DataType != nil {
		return *m.DataType
	}
	return Default_TensorProto_DataType
}

func (m *TensorProto) GetStorageType() TensorProto_StorageType {
	if m != nil && m.StorageType != nil {
		return *m.StorageType
	}
	return Default_TensorProto_StorageType
}

func (m *TensorProto) GetFloatData() []float32 {
	if m != nil {
		return m.FloatData
	}
	return nil
}

func (m *TensorProto) GetInt32Data() []int32 {
	if m != nil {
		return m.Int32Data
	}
	return nil
}

func (m *TensorProto) GetByteData() []byte {
	if m != nil {
		return m.ByteData
	}
	return nil
}

func (m *TensorProto) GetStringData() [][]byte {
	if m != nil {
		return m.StringData
	}
	return nil
}

func (m *TensorProto) GetDoubleData() []float64 {
	if m != nil {
		return m.DoubleData
	}
	return nil
}

func (m *TensorProto) GetInt64Data() []int64 {
	if m != nil {
		return m.Int64Data
	}
	return nil
}

func (m *TensorProto) GetRawData() []byte {
	if m != nil {
		return m.RawData
	}
	return nil
}

func (m *TensorProto) GetExternalData() *ExternalDataProto {
	if m != nil {
		return m.ExternalData
	}
	return nil
}

func (m *TensorProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TensorProto) GetDeviceDetail() *DeviceOption {
	if m != nil {
		return m.DeviceDetail
	}
	return nil
}

func (m *TensorProto) GetSegment() *TensorProto_Segment {
	if m != nil {
		return m.Segment
	}
	return nil
}

// When loading from chunks this is going to indicate where to put data in the
// full array. When not used full data have to be present
type TensorProto_Segment struct {
	Begin            *int64 `protobuf:"varint,1,req,name=begin" json:"begin,omitempty"`
	End              *int64 `protobuf:"varint,2,req,name=end" json:"end,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TensorProto_Segment) Reset()                    { *m = TensorProto_Segment{} }
func (m *TensorProto_Segment) String() string            { return proto.CompactTextString(m) }
func (*TensorProto_Segment) ProtoMessage()               {}
func (*TensorProto_Segment) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1, 0} }

func (m *TensorProto_Segment) GetBegin() int64 {
	if m != nil && m.Begin != nil {
		return *m.Begin
	}
	return 0
}

func (m *TensorProto_Segment) GetEnd() int64 {
	if m != nil && m.End != nil {
		return *m.End
	}
	return 0
}

type QTensorProto struct {
	Dims             []int64               `protobuf:"varint,1,rep,name=dims" json:"dims,omitempty"`
	Precision        *int32                `protobuf:"varint,2,req,name=precision" json:"precision,omitempty"`
	Scale            *float64              `protobuf:"fixed64,3,req,name=scale" json:"scale,omitempty"`
	Bias             *float64              `protobuf:"fixed64,4,req,name=bias" json:"bias,omitempty"`
	IsSigned         *bool                 `protobuf:"varint,5,req,name=is_signed,json=isSigned" json:"is_signed,omitempty"`
	Data             []int32               `protobuf:"varint,6,rep,packed,name=data" json:"data,omitempty"`
	Name             *string               `protobuf:"bytes,7,opt,name=name" json:"name,omitempty"`
	DataType         *TensorProto_DataType `protobuf:"varint,8,opt,name=data_type,json=dataType,enum=caffe2.TensorProto_DataType,def=2" json:"data_type,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *QTensorProto) Reset()                    { *m = QTensorProto{} }
func (m *QTensorProto) String() string            { return proto.CompactTextString(m) }
func (*QTensorProto) ProtoMessage()               {}
func (*QTensorProto) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

const Default_QTensorProto_DataType TensorProto_DataType = TensorProto_INT32

func (m *QTensorProto) GetDims() []int64 {
	if m != nil {
		return m.Dims
	}
	return nil
}

func (m *QTensorProto) GetPrecision() int32 {
	if m != nil && m.Precision != nil {
		return *m.Precision
	}
	return 0
}

func (m *QTensorProto) GetScale() float64 {
	if m != nil && m.Scale != nil {
		return *m.Scale
	}
	return 0
}

func (m *QTensorProto) GetBias() float64 {
	if m != nil && m.Bias != nil {
		return *m.Bias
	}
	return 0
}

func (m *QTensorProto) GetIsSigned() bool {
	if m != nil && m.IsSigned != nil {
		return *m.IsSigned
	}
	return false
}

func (m *QTensorProto) GetData() []int32 {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *QTensorProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *QTensorProto) GetDataType() TensorProto_DataType {
	if m != nil && m.DataType != nil {
		return *m.DataType
	}
	return Default_QTensorProto_DataType
}

// TensorProtos stores multiple TensorProto objects in one single proto. This
// is useful for small tensors; For anything big, consider using a DB for
// storage.
type TensorProtos struct {
	Protos           []*TensorProto `protobuf:"bytes,1,rep,name=protos" json:"protos,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *TensorProtos) Reset()                    { *m = TensorProtos{} }
func (m *TensorProtos) String() string            { return proto.CompactTextString(m) }
func (*TensorProtos) ProtoMessage()               {}
func (*TensorProtos) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *TensorProtos) GetProtos() []*TensorProto {
	if m != nil {
		return m.Protos
	}
	return nil
}

type TensorShape struct {
	Dims             []int64               `protobuf:"varint,1,rep,name=dims" json:"dims,omitempty"`
	DataType         *TensorProto_DataType `protobuf:"varint,2,opt,name=data_type,json=dataType,enum=caffe2.TensorProto_DataType,def=1" json:"data_type,omitempty"`
	UnknownDims      []int32               `protobuf:"varint,3,rep,name=unknown_dims,json=unknownDims" json:"unknown_dims,omitempty"`
	UnknownShape     *bool                 `protobuf:"varint,4,opt,name=unknown_shape,json=unknownShape,def=0" json:"unknown_shape,omitempty"`
	Name             *string               `protobuf:"bytes,5,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *TensorShape) Reset()                    { *m = TensorShape{} }
func (m *TensorShape) String() string            { return proto.CompactTextString(m) }
func (*TensorShape) ProtoMessage()               {}
func (*TensorShape) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

const Default_TensorShape_DataType TensorProto_DataType = TensorProto_FLOAT
const Default_TensorShape_UnknownShape bool = false

func (m *TensorShape) GetDims() []int64 {
	if m != nil {
		return m.Dims
	}
	return nil
}

func (m *TensorShape) GetDataType() TensorProto_DataType {
	if m != nil && m.DataType != nil {
		return *m.DataType
	}
	return Default_TensorShape_DataType
}

func (m *TensorShape) GetUnknownDims() []int32 {
	if m != nil {
		return m.UnknownDims
	}
	return nil
}

func (m *TensorShape) GetUnknownShape() bool {
	if m != nil && m.UnknownShape != nil {
		return *m.UnknownShape
	}
	return Default_TensorShape_UnknownShape
}

func (m *TensorShape) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type TensorShapes struct {
	Shapes           []*TensorShape `protobuf:"bytes,1,rep,name=shapes" json:"shapes,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *TensorShapes) Reset()                    { *m = TensorShapes{} }
func (m *TensorShapes) String() string            { return proto.CompactTextString(m) }
func (*TensorShapes) ProtoMessage()               {}
func (*TensorShapes) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *TensorShapes) GetShapes() []*TensorShape {
	if m != nil {
		return m.Shapes
	}
	return nil
}

// A named argument containing either singular float, integer and string
// values, or repeated float, int and string arrays.
type Argument struct {
	Name             *string        `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	F                *float32       `protobuf:"fixed32,2,opt,name=f" json:"f,omitempty"`
	I                *int64         `protobuf:"varint,3,opt,name=i" json:"i,omitempty"`
	S                []byte         `protobuf:"bytes,4,opt,name=s" json:"s,omitempty"`
	T                *TensorProto   `protobuf:"bytes,10,opt,name=t" json:"t,omitempty"`
	N                *NetDef        `protobuf:"bytes,8,opt,name=n" json:"n,omitempty"`
	Floats           []float32      `protobuf:"fixed32,5,rep,name=floats" json:"floats,omitempty"`
	Ints             []int64        `protobuf:"varint,6,rep,name=ints" json:"ints,omitempty"`
	Strings          [][]byte       `protobuf:"bytes,7,rep,name=strings" json:"strings,omitempty"`
	Tensors          []*TensorProto `protobuf:"bytes,11,rep,name=tensors" json:"tensors,omitempty"`
	Nets             []*NetDef      `protobuf:"bytes,9,rep,name=nets" json:"nets,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Argument) Reset()                    { *m = Argument{} }
func (m *Argument) String() string            { return proto.CompactTextString(m) }
func (*Argument) ProtoMessage()               {}
func (*Argument) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

func (m *Argument) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Argument) GetF() float32 {
	if m != nil && m.F != nil {
		return *m.F
	}
	return 0
}

func (m *Argument) GetI() int64 {
	if m != nil && m.I != nil {
		return *m.I
	}
	return 0
}

func (m *Argument) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *Argument) GetT() *TensorProto {
	if m != nil {
		return m.T
	}
	return nil
}

func (m *Argument) GetN() *NetDef {
	if m != nil {
		return m.N
	}
	return nil
}

func (m *Argument) GetFloats() []float32 {
	if m != nil {
		return m.Floats
	}
	return nil
}

func (m *Argument) GetInts() []int64 {
	if m != nil {
		return m.Ints
	}
	return nil
}

func (m *Argument) GetStrings() [][]byte {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *Argument) GetTensors() []*TensorProto {
	if m != nil {
		return m.Tensors
	}
	return nil
}

func (m *Argument) GetNets() []*NetDef {
	if m != nil {
		return m.Nets
	}
	return nil
}

// Device-specific options. We do not distinguish DeviceOption protos for
// different DeviceTypes, so currently all devices share the same DeviceOption
// proto. Fields that are specific to a device type is ignored if the type does
// not match.
// Note: if you add fields to the DeviceOption, make sure you add the
// corresponding changes to IsSameDevice() function in utils/proto_utils.{h,cc}.
type DeviceOption struct {
	// [general] Options that need to be carried out before running the execution.
	// optional DeviceType device_type = 1 [ default = CPU ];
	DeviceType *int32 `protobuf:"varint,1,opt,name=device_type,json=deviceType,def=0" json:"device_type,omitempty"`
	// [general] Used together with device_type to identify the exact device
	DeviceId *int32 `protobuf:"varint,2,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// [general] The random seed to start the device random number generator with.
	RandomSeed *uint32 `protobuf:"varint,3,opt,name=random_seed,json=randomSeed" json:"random_seed,omitempty"`
	// [general] What node this op should execute on.
	// Used for net transformation purposes. Must be empty at execution time.
	NodeName *string `protobuf:"bytes,4,opt,name=node_name,json=nodeName" json:"node_name,omitempty"`
	// [CPU and Linux specific] NUMA node id
	NumaNodeId *int32 `protobuf:"varint,5,opt,name=numa_node_id,json=numaNodeId" json:"numa_node_id,omitempty"`
	// [general] Extra information passed, not used at execution time currently.
	ExtraInfo        []string `protobuf:"bytes,6,rep,name=extra_info,json=extraInfo" json:"extra_info,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *DeviceOption) Reset()                    { *m = DeviceOption{} }
func (m *DeviceOption) String() string            { return proto.CompactTextString(m) }
func (*DeviceOption) ProtoMessage()               {}
func (*DeviceOption) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7} }

const Default_DeviceOption_DeviceType int32 = 0

func (m *DeviceOption) GetDeviceType() int32 {
	if m != nil && m.DeviceType != nil {
		return *m.DeviceType
	}
	return Default_DeviceOption_DeviceType
}

func (m *DeviceOption) GetDeviceId() int32 {
	if m != nil && m.DeviceId != nil {
		return *m.DeviceId
	}
	return 0
}

func (m *DeviceOption) GetRandomSeed() uint32 {
	if m != nil && m.RandomSeed != nil {
		return *m.RandomSeed
	}
	return 0
}

func (m *DeviceOption) GetNodeName() string {
	if m != nil && m.NodeName != nil {
		return *m.NodeName
	}
	return ""
}

func (m *DeviceOption) GetNumaNodeId() int32 {
	if m != nil && m.NumaNodeId != nil {
		return *m.NumaNodeId
	}
	return 0
}

func (m *DeviceOption) GetExtraInfo() []string {
	if m != nil {
		return m.ExtraInfo
	}
	return nil
}

// Operator Definition.
type OperatorDef struct {
	Input  []string `protobuf:"bytes,1,rep,name=input" json:"input,omitempty"`
	Output []string `protobuf:"bytes,2,rep,name=output" json:"output,omitempty"`
	Name   *string  `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// the operator type. This is needed to create the object from the operator
	// registry.
	Type *string `protobuf:"bytes,4,opt,name=type" json:"type,omitempty"`
	// arg is for the argument defined in operator schema
	Arg []*Argument `protobuf:"bytes,5,rep,name=arg" json:"arg,omitempty"`
	// The device option that the operator should run under.
	DeviceOption *DeviceOption `protobuf:"bytes,6,opt,name=device_option,json=deviceOption" json:"device_option,omitempty"`
	// Optionally, one can specify an engine when there are multiple
	// implementations available simultaneously for one device type.
	// If one specifies an engine but that engine does not exist in the compiled
	// Caffe2 binary, Caffe2 will fall back to the default engine of that device
	// type.
	Engine *string `protobuf:"bytes,7,opt,name=engine" json:"engine,omitempty"`
	// Additional 'fake' inputs used for expressing control dependencies
	// in the operator graph. This can be used to ensure that an
	// operator does not run until another operator is ready, for e.g.
	// scheduling control. These are not passed as actual inputs to the
	// Operator implementation, and are only used by the Net class for
	// scheduling purposes.
	ControlInput []string `protobuf:"bytes,8,rep,name=control_input,json=controlInput" json:"control_input,omitempty"`
	// is_gradient_op argument is only used as a hint in shape inference
	// and has no runtime significance
	IsGradientOp *bool `protobuf:"varint,9,opt,name=is_gradient_op,json=isGradientOp,def=0" json:"is_gradient_op,omitempty"`
	// debug information associated with the construction of the operator.
	// This is an optional string with no assumed characteristics as
	// operators can be constructed in any language.
	DebugInfo *string `protobuf:"bytes,10,opt,name=debug_info,json=debugInfo" json:"debug_info,omitempty"`
	// the domain of the operator to help runtime distinguish which operator
	// library this OperatorDef refers to. For example, both caffe2 and aten
	// has `Add` operator, with domain, we can easily decide which operator
	// to execute. to support multiple operator libs, we use domain to
	// distinguish which operator lib we refer to:
	//   - "caffe2" means this uses Caffe2 operator library
	//   - "aten" means this uses ATen operator library
	//   - "c10" is for the fused library
	//   - if the domain is missing or empty, we use "caffe2", this is for
	//     legacy models, new serializer should always export an OperatorDef
	//     with domain and op_version
	Domain *string `protobuf:"bytes,11,opt,name=domain" json:"domain,omitempty"`
	// each operator is has its own version number.
	// operator version information
	// each time, we change the API or semantics of the operator,
	// we bump the version for the operator.
	// the runtime system should check the op_version of each OperatorDef
	// and decide it should reject or accept the model
	OpVersion        *int64 `protobuf:"varint,12,opt,name=op_version,json=opVersion" json:"op_version,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *OperatorDef) Reset()                    { *m = OperatorDef{} }
func (m *OperatorDef) String() string            { return proto.CompactTextString(m) }
func (*OperatorDef) ProtoMessage()               {}
func (*OperatorDef) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{8} }

const Default_OperatorDef_IsGradientOp bool = false

func (m *OperatorDef) GetInput() []string {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *OperatorDef) GetOutput() []string {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *OperatorDef) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *OperatorDef) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *OperatorDef) GetArg() []*Argument {
	if m != nil {
		return m.Arg
	}
	return nil
}

func (m *OperatorDef) GetDeviceOption() *DeviceOption {
	if m != nil {
		return m.DeviceOption
	}
	return nil
}

func (m *OperatorDef) GetEngine() string {
	if m != nil && m.Engine != nil {
		return *m.Engine
	}
	return ""
}

func (m *OperatorDef) GetControlInput() []string {
	if m != nil {
		return m.ControlInput
	}
	return nil
}

func (m *OperatorDef) GetIsGradientOp() bool {
	if m != nil && m.IsGradientOp != nil {
		return *m.IsGradientOp
	}
	return Default_OperatorDef_IsGradientOp
}

func (m *OperatorDef) GetDebugInfo() string {
	if m != nil && m.DebugInfo != nil {
		return *m.DebugInfo
	}
	return ""
}

func (m *OperatorDef) GetDomain() string {
	if m != nil && m.Domain != nil {
		return *m.Domain
	}
	return ""
}

func (m *OperatorDef) GetOpVersion() int64 {
	if m != nil && m.OpVersion != nil {
		return *m.OpVersion
	}
	return 0
}

// Network definition.
type NetDef struct {
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Operators that the network contains.
	// Note: this is not named "operator" because that is a reserved word in C++.
	Op []*OperatorDef `protobuf:"bytes,2,rep,name=op" json:"op,omitempty"`
	// The type of network that the net should be run with. This routes the
	// network instantiation to different execution modes. The default mode,
	// "simple", runs the operators in a sequential way as the original Caffe
	// implementation does.
	Type *string `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	// the number of workers, if the operators in the network is to be carried out
	// in parallel.
	// Note: This is to be deprecated. Using the arg field with "num_workers" as
	// key.
	NumWorkers *int32 `protobuf:"varint,4,opt,name=num_workers,json=numWorkers" json:"num_workers,omitempty"`
	// The device option for the network. If a network has a specific device
	// option and one of its operators does not have it set, we will copy over the
	// device option to the operator. This allows us to basically avoid putting
	// device options at every operator.
	DeviceOption *DeviceOption `protobuf:"bytes,5,opt,name=device_option,json=deviceOption" json:"device_option,omitempty"`
	Arg          []*Argument   `protobuf:"bytes,6,rep,name=arg" json:"arg,omitempty"`
	// Two optional fields to declare external input and output of a net.
	// If these two are set, when a net is created, we will sanity check for
	// every op whether its input is declared (either as an external input,
	// or as an intermediate blob created by one of the ops), and sanity check
	// if all blobs in external_output are produced.
	//
	// In cases of memory optimization, declaring external_input and
	// external_output also ensures that storage of these blobs are persistent:
	// for any blob in external_input and external_output, after a network run
	// finishes, their content are actually the right content. Any intermediate
	// blobs' contents may be overwritten.
	ExternalInput    []string `protobuf:"bytes,7,rep,name=external_input,json=externalInput" json:"external_input,omitempty"`
	ExternalOutput   []string `protobuf:"bytes,8,rep,name=external_output,json=externalOutput" json:"external_output,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *NetDef) Reset()                    { *m = NetDef{} }
func (m *NetDef) String() string            { return proto.CompactTextString(m) }
func (*NetDef) ProtoMessage()               {}
func (*NetDef) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{9} }

func (m *NetDef) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NetDef) GetOp() []*OperatorDef {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *NetDef) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *NetDef) GetNumWorkers() int32 {
	if m != nil && m.NumWorkers != nil {
		return *m.NumWorkers
	}
	return 0
}

func (m *NetDef) GetDeviceOption() *DeviceOption {
	if m != nil {
		return m.DeviceOption
	}
	return nil
}

func (m *NetDef) GetArg() []*Argument {
	if m != nil {
		return m.Arg
	}
	return nil
}

func (m *NetDef) GetExternalInput() []string {
	if m != nil {
		return m.ExternalInput
	}
	return nil
}

func (m *NetDef) GetExternalOutput() []string {
	if m != nil {
		return m.ExternalOutput
	}
	return nil
}

// ExecutionStep is actually a sort-of-hacky way we simulate iteration right
// now.
type ExecutionStep struct {
	// ExecutionStep should either contain a set of substeps, or a set of
	// network names to run in this execution step. They should NOT both be set
	// at the same time.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// An execution step could be recursive, in which it involves a set of
	// substeps.
	Substep []*ExecutionStep `protobuf:"bytes,2,rep,name=substep" json:"substep,omitempty"`
	// Alternatively, an execution step could involve one or more networks.
	// Note that you cannot have both substeps and networks. Choose one.
	// Note that an execution step refers networks by their name. The actual
	// network definition of the same name should be included in the network field
	// of the plan. The reason is that a network object might hold internal states
	// (think of a data layer), so we want to have the same network object that
	// multiple steps could ask to run.
	Network []string `protobuf:"bytes,3,rep,name=network" json:"network,omitempty"`
	// Number of iterations to run this step. The substeps or the networks
	// specified will be run sequentially, and one sequential run is considered
	// one iteration. If this is not set, the number of iterations is assumed to
	// be 1.
	NumIter *int64 `protobuf:"varint,4,opt,name=num_iter,json=numIter" json:"num_iter,omitempty"`
	// Criteria network specifies a single output (TensorCPU<bool>) of
	// size (1), is run on every iteration by the executor, and
	// execution terminates when the output[0] is `false`.
	CriteriaNetwork *string `protobuf:"bytes,5,opt,name=criteria_network,json=criteriaNetwork" json:"criteria_network,omitempty"`
	// DEPRECATED. Use `run_every_ms`.
	ReportNet      *string `protobuf:"bytes,7,opt,name=report_net,json=reportNet" json:"report_net,omitempty"`
	ReportInterval *int32  `protobuf:"varint,8,opt,name=report_interval,json=reportInterval" json:"report_interval,omitempty"`
	// If provided, execute this step at every time interval (in millisecs)
	// while its sibiling execution steps execute in parallel. This step is
	// guaranteed to run at least once after all non-interval siblings finished.
	RunEveryMs *int64 `protobuf:"varint,11,opt,name=run_every_ms,json=runEveryMs" json:"run_every_ms,omitempty"`
	// If false or not set, execute sub-steps serially.
	// If true, execute all substeps concurrently, each one in a separte thread.
	ConcurrentSubsteps *bool `protobuf:"varint,6,opt,name=concurrent_substeps,json=concurrentSubsteps" json:"concurrent_substeps,omitempty"`
	// Name of a scalar boolean tensor.
	// ES checks this blob AFTER every substeps/subnets.
	// If specified, and the value is true, then ES will skip the rest and return
	// immediately.
	// This means that the report_net and the first step will always be called.
	// Use cases:
	// 1) the first substep stops the rest if data condition not met
	// 2) the first substep decide which of the rest of the steps should be run.
	// 3) external control
	//
	// ** It is the user's responsibility to not to put this blob in race conditions.
	// ** For example when setting this blob in concurrent substeps
	ShouldStopBlob *string `protobuf:"bytes,9,opt,name=should_stop_blob,json=shouldStopBlob" json:"should_stop_blob,omitempty"`
	// if only_once is true, this step will only be executed once. this ONLY takes
	// effect when using should_stop_blob
	OnlyOnce *bool `protobuf:"varint,10,opt,name=only_once,json=onlyOnce" json:"only_once,omitempty"`
	// Whether to create a child workspace for this step.
	// If yes, the workflow and nets are re-created every time this step is run.
	CreateWorkspace *bool `protobuf:"varint,12,opt,name=create_workspace,json=createWorkspace" json:"create_workspace,omitempty"`
	// How many copies of the children execution steps to run concurrently.
	NumConcurrentInstances *int32 `protobuf:"varint,13,opt,name=num_concurrent_instances,json=numConcurrentInstances" json:"num_concurrent_instances,omitempty"`
	XXX_unrecognized       []byte `json:"-"`
}

func (m *ExecutionStep) Reset()                    { *m = ExecutionStep{} }
func (m *ExecutionStep) String() string            { return proto.CompactTextString(m) }
func (*ExecutionStep) ProtoMessage()               {}
func (*ExecutionStep) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{10} }

func (m *ExecutionStep) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ExecutionStep) GetSubstep() []*ExecutionStep {
	if m != nil {
		return m.Substep
	}
	return nil
}

func (m *ExecutionStep) GetNetwork() []string {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *ExecutionStep) GetNumIter() int64 {
	if m != nil && m.NumIter != nil {
		return *m.NumIter
	}
	return 0
}

func (m *ExecutionStep) GetCriteriaNetwork() string {
	if m != nil && m.CriteriaNetwork != nil {
		return *m.CriteriaNetwork
	}
	return ""
}

func (m *ExecutionStep) GetReportNet() string {
	if m != nil && m.ReportNet != nil {
		return *m.ReportNet
	}
	return ""
}

func (m *ExecutionStep) GetReportInterval() int32 {
	if m != nil && m.ReportInterval != nil {
		return *m.ReportInterval
	}
	return 0
}

func (m *ExecutionStep) GetRunEveryMs() int64 {
	if m != nil && m.RunEveryMs != nil {
		return *m.RunEveryMs
	}
	return 0
}

func (m *ExecutionStep) GetConcurrentSubsteps() bool {
	if m != nil && m.ConcurrentSubsteps != nil {
		return *m.ConcurrentSubsteps
	}
	return false
}

func (m *ExecutionStep) GetShouldStopBlob() string {
	if m != nil && m.ShouldStopBlob != nil {
		return *m.ShouldStopBlob
	}
	return ""
}

func (m *ExecutionStep) GetOnlyOnce() bool {
	if m != nil && m.OnlyOnce != nil {
		return *m.OnlyOnce
	}
	return false
}

func (m *ExecutionStep) GetCreateWorkspace() bool {
	if m != nil && m.CreateWorkspace != nil {
		return *m.CreateWorkspace
	}
	return false
}

func (m *ExecutionStep) GetNumConcurrentInstances() int32 {
	if m != nil && m.NumConcurrentInstances != nil {
		return *m.NumConcurrentInstances
	}
	return 0
}

type PlanDef struct {
	// All the networks that are used in this execution. Note that networks should
	// be ordered in the way they are executed, i.e. for a layer in a network, all
	// its input blobs should already have been initialized by the layers or
	// networks defined before it.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The networks that are going to be used in this plan.
	Network          []*NetDef        `protobuf:"bytes,2,rep,name=network" json:"network,omitempty"`
	ExecutionStep    []*ExecutionStep `protobuf:"bytes,3,rep,name=execution_step,json=executionStep" json:"execution_step,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *PlanDef) Reset()                    { *m = PlanDef{} }
func (m *PlanDef) String() string            { return proto.CompactTextString(m) }
func (*PlanDef) ProtoMessage()               {}
func (*PlanDef) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{11} }

func (m *PlanDef) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *PlanDef) GetNetwork() []*NetDef {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *PlanDef) GetExecutionStep() []*ExecutionStep {
	if m != nil {
		return m.ExecutionStep
	}
	return nil
}

// Protobuf format for blobs that are not Tensors. We use a key to store the
// type of the blob. For example for a serialized DBProto, the type should
// be "DBReader" and the content should be a serialized DBProto object.
type BlobProto struct {
	Name    *string       `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Type    *string       `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Tensor  *TensorProto  `protobuf:"bytes,3,opt,name=tensor" json:"tensor,omitempty"`
	Content []byte        `protobuf:"bytes,4,opt,name=content" json:"content,omitempty"`
	Qtensor *QTensorProto `protobuf:"bytes,5,opt,name=qtensor" json:"qtensor,omitempty"`
	// If blob is not Tensor and is divided into chunks, content_num_chunks
	// contains number of chunks, into which blob was divided.
	ContentNumChunks *int32 `protobuf:"varint,6,opt,name=content_num_chunks,json=contentNumChunks" json:"content_num_chunks,omitempty"`
	ContentChunkId   *int32 `protobuf:"varint,7,opt,name=content_chunk_id,json=contentChunkId" json:"content_chunk_id,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *BlobProto) Reset()                    { *m = BlobProto{} }
func (m *BlobProto) String() string            { return proto.CompactTextString(m) }
func (*BlobProto) ProtoMessage()               {}
func (*BlobProto) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{12} }

func (m *BlobProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *BlobProto) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *BlobProto) GetTensor() *TensorProto {
	if m != nil {
		return m.Tensor
	}
	return nil
}

func (m *BlobProto) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *BlobProto) GetQtensor() *QTensorProto {
	if m != nil {
		return m.Qtensor
	}
	return nil
}

func (m *BlobProto) GetContentNumChunks() int32 {
	if m != nil && m.ContentNumChunks != nil {
		return *m.ContentNumChunks
	}
	return 0
}

func (m *BlobProto) GetContentChunkId() int32 {
	if m != nil && m.ContentChunkId != nil {
		return *m.ContentChunkId
	}
	return 0
}

// Protobuf format to serialize DBReader.
type DBReaderProto struct {
	// The name for the DB object in the workspace.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The source of the DB
	Source *string `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	// The type of the DB
	DbType *string `protobuf:"bytes,3,opt,name=db_type,json=dbType" json:"db_type,omitempty"`
	// The current key of the DB if the DB supports seeking.
	Key              *string `protobuf:"bytes,4,opt,name=key" json:"key,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DBReaderProto) Reset()                    { *m = DBReaderProto{} }
func (m *DBReaderProto) String() string            { return proto.CompactTextString(m) }
func (*DBReaderProto) ProtoMessage()               {}
func (*DBReaderProto) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{13} }

func (m *DBReaderProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DBReaderProto) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *DBReaderProto) GetDbType() string {
	if m != nil && m.DbType != nil {
		return *m.DbType
	}
	return ""
}

func (m *DBReaderProto) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func init() {
	proto.RegisterType((*ExternalDataProto)(nil), "caffe2.ExternalDataProto")
	proto.RegisterType((*TensorProto)(nil), "caffe2.TensorProto")
	proto.RegisterType((*TensorProto_Segment)(nil), "caffe2.TensorProto.Segment")
	proto.RegisterType((*QTensorProto)(nil), "caffe2.QTensorProto")
	proto.RegisterType((*TensorProtos)(nil), "caffe2.TensorProtos")
	proto.RegisterType((*TensorShape)(nil), "caffe2.TensorShape")
	proto.RegisterType((*TensorShapes)(nil), "caffe2.TensorShapes")
	proto.RegisterType((*Argument)(nil), "caffe2.Argument")
	proto.RegisterType((*DeviceOption)(nil), "caffe2.DeviceOption")
	proto.RegisterType((*OperatorDef)(nil), "caffe2.OperatorDef")
	proto.RegisterType((*NetDef)(nil), "caffe2.NetDef")
	proto.RegisterType((*ExecutionStep)(nil), "caffe2.ExecutionStep")
	proto.RegisterType((*PlanDef)(nil), "caffe2.PlanDef")
	proto.RegisterType((*BlobProto)(nil), "caffe2.BlobProto")
	proto.RegisterType((*DBReaderProto)(nil), "caffe2.DBReaderProto")
	proto.RegisterEnum("caffe2.DeviceTypeProto", DeviceTypeProto_name, DeviceTypeProto_value)
	proto.RegisterEnum("caffe2.ExternalDataProto_SourceType", ExternalDataProto_SourceType_name, ExternalDataProto_SourceType_value)
	proto.RegisterEnum("caffe2.TensorProto_DataType", TensorProto_DataType_name, TensorProto_DataType_value)
	proto.RegisterEnum("caffe2.TensorProto_StorageType", TensorProto_StorageType_name, TensorProto_StorageType_value)
}

func init() { proto.RegisterFile("caffe2/proto/caffe2.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 1928 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x4f, 0x93, 0xdb, 0x48,
	0xf9, 0x8e, 0x24, 0xcb, 0x96, 0x5e, 0xdb, 0x13, 0xfd, 0x3a, 0xf9, 0x0d, 0x1a, 0x92, 0xad, 0x38,
	0x1e, 0xa8, 0x35, 0x1b, 0x76, 0x42, 0x26, 0x61, 0x6a, 0x09, 0x14, 0x30, 0x33, 0xd6, 0x04, 0x15,
	0x1e, 0xd9, 0xdb, 0xf6, 0x6c, 0x36, 0x27, 0x95, 0x6c, 0xb5, 0x1d, 0x55, 0xec, 0x96, 0x91, 0xe4,
	0x24, 0xb3, 0xc7, 0xad, 0xe2, 0x1b, 0x70, 0xa7, 0x0a, 0x8a, 0x03, 0x5f, 0x84, 0x23, 0x1f, 0x80,
	0x6f, 0xc1, 0x81, 0x33, 0x54, 0xbf, 0xdd, 0xb2, 0x1d, 0x66, 0x66, 0x77, 0x2f, 0xdc, 0xf4, 0x3e,
	0xef, 0xd3, 0x7f, 0xfc, 0xbc, 0xff, 0xda, 0xb0, 0x37, 0x89, 0xa6, 0x53, 0x76, 0xf8, 0x78, 0x99,
	0xa5, 0x45, 0xfa, 0x58, 0x1a, 0x07, 0x68, 0x90, 0xaa, 0xb4, 0xda, 0x7f, 0xd0, 0xe1, 0xff, 0xbc,
	0xf7, 0x05, 0xcb, 0x78, 0x34, 0xef, 0x46, 0x45, 0x34, 0x40, 0xef, 0x4b, 0xa8, 0xe7, 0xe9, 0x2a,
	0x9b, 0xb0, 0xb0, 0xb8, 0x5c, 0x32, 0x57, 0x6b, 0x69, 0x9d, 0x9d, 0xc3, 0x1f, 0x1c, 0xa8, 0x1d,
	0xae, 0xf0, 0x0f, 0x86, 0x48, 0x1e, 0x5d, 0x2e, 0xd9, 0x73, 0xc7, 0x0f, 0x7a, 0x7e, 0xe0, 0x85,
	0xa7, 0xfd, 0x60, 0x74, 0xec, 0x07, 0x1e, 0xa5, 0x90, 0xaf, 0xbd, 0xe4, 0x1e, 0xd8, 0x19, 0x9b,
	0xa4, 0x59, 0x1c, 0x26, 0xb1, 0xab, 0xb7, 0xb4, 0x8e, 0x4d, 0x2d, 0x09, 0xf8, 0x31, 0x79, 0x00,
	0x75, 0xe5, 0xcc, 0x93, 0xaf, 0x98, 0x6b, 0xb6, 0xb4, 0x4e, 0x85, 0x82, 0x84, 0x86, 0xc9, 0x57,
	0x8c, 0xec, 0x41, 0x35, 0x9d, 0x4e, 0x73, 0x56, 0xb8, 0x46, 0x4b, 0xeb, 0x18, 0xcf, 0xb5, 0x9f,
	0x50, 0x05, 0x10, 0x17, 0x6a, 0x79, 0x91, 0x25, 0x31, 0xcb, 0xdd, 0x4a, 0xcb, 0xe8, 0x18, 0xb4,
	0x34, 0xdb, 0x4f, 0x01, 0x36, 0xd7, 0x23, 0x77, 0xe1, 0xca, 0x05, 0x9d, 0x5b, 0xe4, 0x36, 0xd4,
	0x87, 0xfe, 0xf9, 0xa0, 0xe7, 0x85, 0x67, 0x7e, 0xcf, 0x73, 0xb4, 0xf6, 0x3f, 0xab, 0x50, 0x1f,
	0x31, 0x9e, 0xa7, 0x99, 0x14, 0x84, 0x40, 0x25, 0x4e, 0x16, 0xb9, 0xab, 0xe1, 0xde, 0xf8, 0x4d,
	0x7e, 0x0d, 0x76, 0x1c, 0x15, 0x91, 0x94, 0x48, 0x47, 0x89, 0xee, 0x97, 0x12, 0x6d, 0xad, 0x3d,
	0x10, 0x32, 0xa1, 0x34, 0xe6, 0x59, 0xaf, 0x7f, 0x3c, 0xa2, 0x56, 0xac, 0x00, 0xe2, 0x43, 0x23,
	0x2f, 0xd2, 0x2c, 0x9a, 0x29, 0x9d, 0x1b, 0xb8, 0xc9, 0x83, 0xeb, 0x36, 0x19, 0x4a, 0x9e, 0xdc,
	0x67, 0xf4, 0x6a, 0xe0, 0x75, 0x69, 0x3d, 0xdf, 0x60, 0xe4, 0x21, 0xc0, 0x74, 0x9e, 0x46, 0x45,
	0x28, 0x36, 0x77, 0x8d, 0x96, 0xd1, 0xd1, 0x4f, 0x74, 0x47, 0xa3, 0x36, 0xa2, 0xe2, 0x0a, 0x82,
	0x92, 0xf0, 0xe2, 0xe9, 0xa1, 0xa4, 0x08, 0x95, 0x4c, 0x49, 0x41, 0x14, 0x29, 0xf7, 0xc0, 0x1e,
	0x5f, 0x16, 0x4c, 0x32, 0x84, 0xfe, 0x0d, 0x6a, 0x09, 0x00, 0x9d, 0x0f, 0xa0, 0x2e, 0x34, 0xe5,
	0x33, 0xe9, 0xae, 0xb6, 0x8c, 0x4e, 0x83, 0x82, 0x84, 0x90, 0xb0, 0x0f, 0xf5, 0x38, 0x5d, 0x8d,
	0xe7, 0x6a, 0xbd, 0xdd, 0x32, 0x3a, 0x1a, 0x9e, 0x00, 0x12, 0xde, 0xba, 0xc5, 0xd1, 0x33, 0xc9,
	0x01, 0xa1, 0xe7, 0xfa, 0x16, 0x47, 0xcf, 0x90, 0xb2, 0x07, 0x56, 0x16, 0xbd, 0x93, 0x84, 0x26,
	0x5e, 0xa2, 0x96, 0x45, 0xef, 0xd0, 0xf5, 0x4b, 0x68, 0x32, 0x95, 0x7d, 0xd2, 0xbf, 0xd3, 0xd2,
	0x3a, 0xf5, 0xc3, 0xbd, 0x1b, 0x53, 0x93, 0x36, 0xd8, 0x16, 0x24, 0xe2, 0xc8, 0xa3, 0x05, 0x73,
	0x6b, 0x98, 0x7a, 0xf8, 0x4d, 0x7e, 0x06, 0xcd, 0x98, 0xbd, 0x4d, 0x26, 0x2c, 0x8c, 0x59, 0x11,
	0x25, 0x73, 0xd7, 0xc2, 0x3d, 0xef, 0x96, 0x7b, 0x76, 0xd1, 0xd9, 0x5f, 0x16, 0x49, 0xca, 0x69,
	0x43, 0x52, 0xbb, 0xc8, 0x24, 0x3f, 0x85, 0x5a, 0xce, 0x66, 0x0b, 0xc6, 0x0b, 0xb7, 0x8e, 0x8b,
	0xee, 0x5d, 0x1b, 0x3b, 0x49, 0xa1, 0x25, 0xf7, 0xfb, 0x4f, 0xa0, 0xa6, 0x30, 0x72, 0x17, 0xcc,
	0x31, 0x9b, 0x25, 0xdc, 0xd5, 0x5a, 0x7a, 0xc7, 0xa0, 0xd2, 0x20, 0x0e, 0x18, 0x8c, 0x8b, 0x02,
	0x11, 0x98, 0xf8, 0x6c, 0xff, 0x51, 0x03, 0xab, 0x4c, 0x24, 0xd2, 0x04, 0xfb, 0x22, 0xe8, 0x7a,
	0x67, 0x7e, 0xe0, 0x75, 0x9d, 0x5b, 0xc4, 0x06, 0x99, 0x59, 0x8e, 0x26, 0x3e, 0xfd, 0x60, 0xf4,
	0xf4, 0xd0, 0xd1, 0x89, 0x05, 0x95, 0x93, 0x57, 0x23, 0xcf, 0x31, 0x08, 0x40, 0x75, 0x38, 0xa2,
	0x7e, 0xf0, 0xc2, 0xa9, 0x20, 0xda, 0xef, 0xf7, 0x1c, 0x53, 0x50, 0x2f, 0xfc, 0x60, 0xf4, 0x99,
	0x53, 0x15, 0x20, 0x7e, 0xd5, 0x04, 0x55, 0x80, 0x4f, 0x8e, 0x1c, 0x4b, 0xed, 0xf5, 0xe4, 0xc8,
	0xb1, 0xd5, 0xe7, 0xd1, 0x33, 0x07, 0x48, 0x1d, 0x6a, 0x78, 0xd8, 0x93, 0x23, 0xa7, 0x21, 0xe8,
	0xdd, 0xfe, 0xc5, 0x49, 0xcf, 0x73, 0x9a, 0xed, 0x5f, 0x41, 0x7d, 0x2b, 0x49, 0xc5, 0x12, 0x4c,
	0x53, 0x47, 0x23, 0x35, 0x30, 0xe8, 0xf1, 0x4b, 0x47, 0x27, 0x0d, 0xb0, 0xbc, 0x2f, 0x47, 0x1e,
	0x0d, 0x8e, 0x7b, 0x8e, 0x41, 0x76, 0x00, 0x82, 0x3e, 0x96, 0xa1, 0x17, 0x8c, 0x9c, 0x4a, 0xfb,
	0x5f, 0x1a, 0x34, 0x3e, 0xff, 0xb6, 0xa2, 0xbb, 0x0f, 0xf6, 0x32, 0x63, 0x93, 0x24, 0x4f, 0x52,
	0x8e, 0xfa, 0x98, 0x74, 0x03, 0x08, 0x35, 0xf3, 0x49, 0x34, 0x67, 0xae, 0xd1, 0xd2, 0x3b, 0x1a,
	0x95, 0x86, 0xd8, 0x67, 0x9c, 0x44, 0xa2, 0x31, 0x08, 0x10, 0xbf, 0x45, 0xa6, 0x27, 0x79, 0x98,
	0x27, 0x33, 0xce, 0x62, 0xd7, 0x6c, 0xe9, 0x1d, 0x8b, 0x5a, 0x49, 0x3e, 0x44, 0x9b, 0xec, 0x42,
	0x65, 0x9d, 0xe2, 0xb2, 0x46, 0xd0, 0xbe, 0x36, 0x7b, 0x3e, 0xe8, 0x02, 0xd6, 0x77, 0xe9, 0x02,
	0x18, 0xa0, 0x4d, 0x17, 0x68, 0xff, 0x1c, 0x1a, 0x5b, 0xc4, 0x9c, 0x3c, 0x82, 0x2a, 0xf6, 0x68,
	0xf9, 0xc3, 0xeb, 0x87, 0x77, 0xae, 0xd9, 0x8e, 0x2a, 0x4a, 0xfb, 0x6f, 0x5a, 0xd9, 0xa8, 0x86,
	0xaf, 0xa3, 0x25, 0xfb, 0x1f, 0x35, 0xaa, 0x87, 0xd0, 0x58, 0xf1, 0x37, 0x3c, 0x7d, 0xc7, 0x43,
	0xdc, 0x5d, 0xf4, 0x17, 0x93, 0xd6, 0x15, 0xd6, 0x15, 0x87, 0x7c, 0x02, 0xcd, 0x92, 0x92, 0x8b,
	0x9b, 0xb8, 0x95, 0x96, 0xd6, 0xb1, 0x9e, 0x9b, 0xd3, 0x68, 0x9e, 0x33, 0x5a, 0x2e, 0x5f, 0x5f,
	0x12, 0x75, 0x34, 0x37, 0x3a, 0x6e, 0x54, 0x40, 0x0a, 0xaa, 0x80, 0xfb, 0xdc, 0xa0, 0x02, 0xb2,
	0xa8, 0xa2, 0xb4, 0xff, 0xa4, 0x83, 0x75, 0x9c, 0xcd, 0x56, 0x58, 0x52, 0xe5, 0xee, 0xda, 0x56,
	0x94, 0x1a, 0xa0, 0x4d, 0xf1, 0xa7, 0xeb, 0x54, 0x9b, 0x0a, 0x2b, 0x91, 0x23, 0x84, 0x6a, 0x89,
	0xb0, 0x72, 0xbc, 0x6d, 0x83, 0x6a, 0x39, 0x79, 0x08, 0x5a, 0xe1, 0x02, 0x16, 0xf3, 0xb5, 0xc2,
	0x6b, 0x05, 0xb9, 0x0f, 0x1a, 0x57, 0x4d, 0x62, 0xa7, 0xa4, 0x04, 0xac, 0xe8, 0xb2, 0x29, 0xd5,
	0x38, 0xd9, 0x85, 0x2a, 0xf6, 0xdc, 0xdc, 0x35, 0x45, 0x17, 0xa6, 0xca, 0x12, 0xd7, 0x4a, 0x78,
	0x91, 0x63, 0x52, 0x19, 0x14, 0xbf, 0xcb, 0xa9, 0xc5, 0x67, 0xb9, 0x5b, 0xc3, 0x76, 0x5a, 0x9a,
	0xe4, 0x53, 0xa8, 0x15, 0x78, 0x6a, 0xee, 0xd6, 0x6f, 0xce, 0x82, 0x92, 0x43, 0xda, 0x50, 0xe1,
	0xac, 0xc8, 0xb1, 0xe7, 0x5e, 0xbd, 0x15, 0xfa, 0xda, 0x7f, 0xd7, 0xa0, 0xb1, 0xdd, 0xcb, 0x48,
	0x1b, 0xea, 0xaa, 0xf1, 0xad, 0xa7, 0xbc, 0x29, 0x66, 0x2a, 0x48, 0xb4, 0x1c, 0xd8, 0x8a, 0xa3,
	0x06, 0xb6, 0x49, 0x2d, 0x09, 0xa8, 0x81, 0x1d, 0xf1, 0x38, 0x5d, 0x84, 0x39, 0x63, 0x31, 0x2a,
	0xda, 0xa4, 0x20, 0xa1, 0x21, 0x63, 0xb1, 0x58, 0xcd, 0xd3, 0x98, 0x85, 0x18, 0x8f, 0x8a, 0x1c,
	0xf7, 0x02, 0x08, 0x44, 0x4c, 0x5a, 0xd0, 0xe0, 0xab, 0x45, 0x14, 0x22, 0x23, 0x89, 0x31, 0x1b,
	0x4c, 0x0a, 0x02, 0x0b, 0xd2, 0x58, 0xec, 0xff, 0x11, 0x00, 0x7b, 0x5f, 0x64, 0x51, 0x98, 0xf0,
	0x69, 0x8a, 0xc2, 0xd9, 0xd4, 0x46, 0xc4, 0xe7, 0xd3, 0xb4, 0xfd, 0xb5, 0x01, 0xf5, 0xfe, 0x92,
	0x65, 0x51, 0x91, 0x66, 0x5d, 0x36, 0x15, 0xd5, 0x9f, 0xf0, 0xe5, 0xaa, 0xc0, 0x8c, 0xb1, 0xa9,
	0x34, 0x44, 0x3c, 0xd2, 0x55, 0x21, 0x60, 0x1d, 0x61, 0x65, 0xad, 0xd3, 0xc4, 0xd8, 0x4a, 0x13,
	0x02, 0x15, 0x94, 0x42, 0x5e, 0x15, 0xbf, 0x49, 0x1b, 0x8c, 0x28, 0x9b, 0x61, 0x30, 0xeb, 0x87,
	0x4e, 0xa9, 0x6c, 0x99, 0x6d, 0x54, 0x38, 0xb7, 0x46, 0x48, 0x8a, 0xd2, 0xba, 0xd5, 0x6f, 0x1f,
	0x21, 0x2a, 0x08, 0xbb, 0x50, 0x65, 0x7c, 0x96, 0xf0, 0xb2, 0xab, 0x28, 0x8b, 0xec, 0x43, 0x73,
	0x92, 0xf2, 0x22, 0x4b, 0xe7, 0xa1, 0xfc, 0x51, 0x16, 0xde, 0xbe, 0xa1, 0x40, 0x1f, 0x7f, 0xdb,
	0x23, 0xd8, 0x49, 0xf2, 0x70, 0x96, 0x45, 0x71, 0xc2, 0x78, 0x11, 0xa6, 0x4b, 0xd7, 0xfe, 0xa0,
	0xea, 0x92, 0xfc, 0x85, 0xf2, 0xf5, 0x97, 0x42, 0xcd, 0x98, 0x8d, 0x57, 0x33, 0xa9, 0x26, 0xe0,
	0x69, 0x36, 0x22, 0x42, 0x4d, 0x71, 0x91, 0x38, 0x5d, 0x44, 0x09, 0xc7, 0x51, 0x66, 0x53, 0x65,
	0x89, 0x65, 0xe9, 0x32, 0x7c, 0xcb, 0x32, 0x6c, 0xb9, 0x0d, 0xac, 0x1a, 0x3b, 0x5d, 0x7e, 0x21,
	0x81, 0xf6, 0x5f, 0x75, 0xa8, 0xca, 0x34, 0xbb, 0xb6, 0xf0, 0xf6, 0x41, 0x4f, 0x97, 0xa8, 0xfc,
	0x56, 0x0a, 0x6f, 0x05, 0x8d, 0xea, 0xe9, 0x72, 0x2d, 0xbb, 0xb1, 0x25, 0xfb, 0x3e, 0xd4, 0xf9,
	0x6a, 0x11, 0xbe, 0x4b, 0xb3, 0x37, 0x2c, 0x93, 0xf5, 0x69, 0x9e, 0xe8, 0xae, 0x86, 0x09, 0xf2,
	0x52, 0xa2, 0x57, 0x75, 0x37, 0xbf, 0xb3, 0xee, 0x2a, 0xac, 0xd5, 0x6f, 0x0a, 0xeb, 0x0f, 0x61,
	0x67, 0xfd, 0xda, 0x90, 0x41, 0xa8, 0x61, 0x10, 0xd6, 0x6f, 0x10, 0x19, 0x85, 0x8f, 0xe1, 0xf6,
	0x9a, 0xa6, 0x52, 0x4d, 0x06, 0x6b, 0xbd, 0xba, 0x8f, 0x68, 0xfb, 0xdf, 0x06, 0x34, 0xbd, 0xf7,
	0x6c, 0xb2, 0x12, 0x37, 0x18, 0x16, 0x6c, 0x79, 0xad, 0x64, 0x8f, 0xa1, 0x96, 0xaf, 0xc6, 0x79,
	0xc1, 0x4a, 0xdd, 0xfe, 0x7f, 0xf3, 0xba, 0xd9, 0x5a, 0x4b, 0x4b, 0x96, 0xe8, 0x22, 0x9c, 0x15,
	0x42, 0x29, 0x6c, 0xcc, 0x36, 0x2d, 0x4d, 0xf1, 0x92, 0x12, 0x22, 0x26, 0x05, 0xcb, 0x50, 0x41,
	0x83, 0xd6, 0xf8, 0x6a, 0xe1, 0x17, 0x2c, 0x23, 0x9f, 0x82, 0x33, 0xc9, 0x84, 0x23, 0x89, 0xc2,
	0x72, 0x35, 0xf6, 0x63, 0x14, 0xf9, 0x76, 0xe9, 0x0b, 0xd4, 0x4e, 0x1f, 0x01, 0x64, 0x6c, 0x99,
	0x66, 0x85, 0x20, 0xab, 0x54, 0xb5, 0x25, 0x12, 0x30, 0x94, 0x40, 0xb9, 0x13, 0x5e, 0xb0, 0xec,
	0x6d, 0x24, 0x5f, 0x51, 0x26, 0xdd, 0x91, 0xb0, 0xaf, 0x50, 0x51, 0xf4, 0xd9, 0x8a, 0x87, 0xec,
	0x2d, 0xcb, 0x2e, 0xc3, 0x45, 0x8e, 0xb9, 0x66, 0x50, 0xc8, 0x56, 0xdc, 0x13, 0xd0, 0x79, 0x4e,
	0x1e, 0xc3, 0x9d, 0x49, 0xca, 0x27, 0xab, 0x2c, 0x13, 0x29, 0xad, 0x7e, 0x63, 0x8e, 0x15, 0x65,
	0x51, 0xb2, 0x71, 0x0d, 0x95, 0x87, 0x74, 0xc0, 0xc9, 0x5f, 0xa7, 0xab, 0x79, 0x1c, 0xe6, 0x45,
	0xba, 0x0c, 0xc7, 0xf3, 0x74, 0x8c, 0x65, 0x60, 0xd3, 0x1d, 0x89, 0x0f, 0x8b, 0x74, 0x79, 0x32,
	0x4f, 0xc7, 0xa2, 0x1d, 0xa5, 0x7c, 0x7e, 0x19, 0xa6, 0x7c, 0xc2, 0xb0, 0x00, 0x2c, 0x6a, 0x09,
	0xa0, 0xcf, 0x27, 0x8c, 0xfc, 0x48, 0x08, 0xc2, 0xa2, 0x82, 0x61, 0xce, 0xe5, 0xcb, 0x68, 0x22,
	0x1f, 0xe4, 0x96, 0x10, 0x43, 0xe0, 0x2f, 0x4b, 0x98, 0x7c, 0x06, 0xae, 0x90, 0x75, 0xeb, 0x9a,
	0x09, 0xcf, 0x8b, 0x88, 0x4f, 0x58, 0x8e, 0x0f, 0x56, 0x93, 0xee, 0xf2, 0xd5, 0xe2, 0x74, 0xed,
	0xf6, 0x4b, 0x6f, 0xfb, 0xf7, 0x1a, 0xd4, 0x06, 0xf3, 0x88, 0xdf, 0x54, 0x2e, 0x9d, 0x4d, 0x28,
	0xf5, 0x6b, 0x5b, 0xf9, 0x3a, 0xb4, 0xbf, 0x10, 0xb9, 0xa9, 0xd2, 0x21, 0xc4, 0x64, 0x31, 0xbe,
	0x29, 0x59, 0x9a, 0x6c, 0xdb, 0x6c, 0x7f, 0xad, 0x83, 0x2d, 0x24, 0x59, 0x3f, 0xb4, 0xae, 0xdc,
	0xa4, 0xac, 0x49, 0x7d, 0xab, 0x26, 0x1f, 0x41, 0x55, 0x0e, 0x1c, 0xac, 0xd4, 0x9b, 0x5e, 0x26,
	0x92, 0x22, 0xb2, 0x52, 0xf4, 0x2a, 0xf1, 0x36, 0x96, 0xc3, 0xb5, 0x34, 0xc9, 0x01, 0xd4, 0x7e,
	0xa7, 0xf6, 0xf9, 0xaf, 0x7a, 0xfd, 0xfc, 0x83, 0xe1, 0xa6, 0x48, 0xe4, 0xc7, 0x40, 0xd4, 0xd2,
	0x10, 0x65, 0x7f, 0xbd, 0xe2, 0x6f, 0x64, 0x42, 0x98, 0xd4, 0x51, 0x9e, 0x60, 0xb5, 0x38, 0x45,
	0x5c, 0xa4, 0x43, 0xc9, 0x46, 0xa6, 0x18, 0x2d, 0x35, 0x99, 0x8b, 0x0a, 0x47, 0xa2, 0x1f, 0xb7,
	0xa7, 0xd0, 0xec, 0x9e, 0x50, 0x16, 0xc5, 0x2c, 0xbb, 0x59, 0x87, 0x5d, 0xa8, 0xca, 0xff, 0xaf,
	0x4a, 0x09, 0x65, 0x91, 0xef, 0x41, 0x2d, 0x1e, 0x87, 0x5b, 0x6d, 0xab, 0x1a, 0x8f, 0x71, 0x62,
	0x3a, 0x60, 0xbc, 0x61, 0x97, 0x6a, 0x84, 0x88, 0xcf, 0x4f, 0xfe, 0xa1, 0xc1, 0xed, 0xee, 0x7a,
	0xa4, 0xca, 0xa3, 0x9a, 0x60, 0x0f, 0x68, 0x7f, 0xd4, 0x0f, 0x4f, 0x07, 0x17, 0xce, 0x2d, 0xf1,
	0x16, 0x56, 0xe6, 0x45, 0xf7, 0xd8, 0xd1, 0x88, 0x03, 0x0d, 0x69, 0x9f, 0xff, 0xb6, 0xd7, 0x0d,
	0x02, 0x47, 0xdf, 0x20, 0xfd, 0x81, 0x17, 0xbc, 0x10, 0xef, 0xe7, 0x0f, 0x90, 0xd3, 0x9e, 0x53,
	0x11, 0x7f, 0x63, 0x25, 0xe2, 0x77, 0x3d, 0x6f, 0xe0, 0x98, 0x9b, 0x53, 0x7e, 0xe3, 0x0f, 0x9c,
	0xea, 0xe6, 0x94, 0xb3, 0xc1, 0x8b, 0x63, 0xa7, 0x46, 0x3e, 0x86, 0x7d, 0x75, 0x6a, 0xff, 0x7c,
	0xe0, 0xf7, 0xbc, 0x70, 0xe4, 0x9f, 0x7b, 0xe1, 0xf9, 0xf1, 0x97, 0x61, 0xd7, 0xfb, 0xc2, 0x3f,
	0xf5, 0x42, 0xf1, 0x82, 0x1f, 0x3a, 0x16, 0xd9, 0x83, 0x3b, 0xea, 0xa8, 0xa0, 0xf7, 0x2a, 0x3c,
	0xeb, 0xd3, 0x70, 0xe4, 0x0d, 0x47, 0xce, 0x5f, 0xfe, 0xac, 0xfd, 0x27, 0x00, 0x00, 0xff, 0xff,
	0x9e, 0xf1, 0x64, 0xad, 0x64, 0x10, 0x00, 0x00,
}
