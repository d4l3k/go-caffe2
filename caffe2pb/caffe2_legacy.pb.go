// Code generated by protoc-gen-go. DO NOT EDIT.
// source: caffe2/proto/caffe2_legacy.proto

package caffe2pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type LegacyPadding int32

const (
	LegacyPadding_NOTSET LegacyPadding = 0
	// VALID and SAME are two strategies adopted in Google DistBelief: it forces
	// the input shape as follows. For SAME, the output is:
	//   R_out = ceil(float(R) / float(S))
	//   C_out = ceil(float(C) / float(S))
	// where R and C are row and column, S is the stride, and K is the kernel.
	// The number of padded pixels is then computed as
	//   Pr = ((R_out - 1) * S + K - R)
	//   Pc = ((C_out - 1) * S + K - C)
	// When Pr and Pc are even numbers, both sides (left and right, or top and
	// bottom) get half each. When Pr and Pc are odd numbers, the right and the
	// bottom gets the one additional padding pixel.
	// For VALID, padding values of 0 are always used.
	LegacyPadding_VALID LegacyPadding = 1
	LegacyPadding_SAME  LegacyPadding = 2
	// CAFFE_LEGACY_POOLING is a flag that notifies the code to use the old Caffe
	// padding strategy.
	// Basically, in caffe2, after padding the convolution and pooling use the
	// same computation strategy: half-windows at the right and bottom are
	// discarded. In Caffe, convolution follows this strategy but if there are
	// some pixels in the half-windows, the pooling layer will actually put one
	// additional output. If you set LegacyPadding to this, we will compute the
	// equivalent padding strategy in caffe2 so that the output size is
	// backward compatible with Caffe.
	// THIS IS NOW DEPRECATED. ANY non-conventional use has to be manually
	// converted.
	LegacyPadding_CAFFE_LEGACY_POOLING LegacyPadding = 3
)

var LegacyPadding_name = map[int32]string{
	0: "NOTSET",
	1: "VALID",
	2: "SAME",
	3: "CAFFE_LEGACY_POOLING",
}
var LegacyPadding_value = map[string]int32{
	"NOTSET":               0,
	"VALID":                1,
	"SAME":                 2,
	"CAFFE_LEGACY_POOLING": 3,
}

func (x LegacyPadding) Enum() *LegacyPadding {
	p := new(LegacyPadding)
	*p = x
	return p
}
func (x LegacyPadding) String() string {
	return proto.EnumName(LegacyPadding_name, int32(x))
}
func (x *LegacyPadding) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LegacyPadding_value, data, "LegacyPadding")
	if err != nil {
		return err
	}
	*x = LegacyPadding(value)
	return nil
}
func (LegacyPadding) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

// Original Caffe1 Datum copy: this is used in image input op to allow us to
// load caffe1 serialized datum without having to regenerate the database.
type CaffeDatum struct {
	Channels *int32 `protobuf:"varint,1,opt,name=channels" json:"channels,omitempty"`
	Height   *int32 `protobuf:"varint,2,opt,name=height" json:"height,omitempty"`
	Width    *int32 `protobuf:"varint,3,opt,name=width" json:"width,omitempty"`
	// the actual image data, in bytes
	Data  []byte `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
	Label *int32 `protobuf:"varint,5,opt,name=label" json:"label,omitempty"`
	// Optionally, the datum could also hold float data.
	FloatData []float32 `protobuf:"fixed32,6,rep,name=float_data,json=floatData" json:"float_data,omitempty"`
	// If true data contains an encoded image that need to be decoded
	Encoded          *bool  `protobuf:"varint,7,opt,name=encoded,def=0" json:"encoded,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CaffeDatum) Reset()                    { *m = CaffeDatum{} }
func (m *CaffeDatum) String() string            { return proto.CompactTextString(m) }
func (*CaffeDatum) ProtoMessage()               {}
func (*CaffeDatum) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

const Default_CaffeDatum_Encoded bool = false

func (m *CaffeDatum) GetChannels() int32 {
	if m != nil && m.Channels != nil {
		return *m.Channels
	}
	return 0
}

func (m *CaffeDatum) GetHeight() int32 {
	if m != nil && m.Height != nil {
		return *m.Height
	}
	return 0
}

func (m *CaffeDatum) GetWidth() int32 {
	if m != nil && m.Width != nil {
		return *m.Width
	}
	return 0
}

func (m *CaffeDatum) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *CaffeDatum) GetLabel() int32 {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return 0
}

func (m *CaffeDatum) GetFloatData() []float32 {
	if m != nil {
		return m.FloatData
	}
	return nil
}

func (m *CaffeDatum) GetEncoded() bool {
	if m != nil && m.Encoded != nil {
		return *m.Encoded
	}
	return Default_CaffeDatum_Encoded
}

func init() {
	proto.RegisterType((*CaffeDatum)(nil), "caffe2.CaffeDatum")
	proto.RegisterEnum("caffe2.LegacyPadding", LegacyPadding_name, LegacyPadding_value)
}

func init() { proto.RegisterFile("caffe2/proto/caffe2_legacy.proto", fileDescriptor5) }

var fileDescriptor5 = []byte{
	// 260 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x3c, 0x8f, 0x4f, 0x4b, 0xc3, 0x30,
	0x18, 0x87, 0x4d, 0xff, 0xad, 0x7b, 0x51, 0x28, 0x2f, 0x43, 0x82, 0x20, 0x06, 0x4f, 0xc5, 0x83,
	0x03, 0x8f, 0xde, 0x4a, 0xdb, 0x8d, 0x49, 0x5d, 0x47, 0x37, 0x04, 0x4f, 0x25, 0x36, 0xe9, 0x1f,
	0x88, 0xad, 0xb8, 0x88, 0xf8, 0xed, 0xfc, 0x68, 0xd2, 0x54, 0xbd, 0xfd, 0x9e, 0x27, 0x4f, 0x0e,
	0x2f, 0xb0, 0x8a, 0xd7, 0xb5, 0xbc, 0x5b, 0xbe, 0xbd, 0x0f, 0x7a, 0x58, 0x4e, 0x50, 0x2a, 0xd9,
	0xf0, 0xea, 0xeb, 0xd6, 0x38, 0xf4, 0x26, 0x79, 0xfd, 0x4d, 0x00, 0xe2, 0x71, 0x26, 0x5c, 0x7f,
	0xbc, 0xe2, 0x05, 0xf8, 0x55, 0xcb, 0xfb, 0x5e, 0xaa, 0x23, 0x25, 0x8c, 0x84, 0x6e, 0xf1, 0xcf,
	0x78, 0x0e, 0x5e, 0x2b, 0xbb, 0xa6, 0xd5, 0xd4, 0x32, 0x2f, 0xbf, 0x84, 0x0b, 0x70, 0x3f, 0x3b,
	0xa1, 0x5b, 0x6a, 0x1b, 0x3d, 0x01, 0x22, 0x38, 0x82, 0x6b, 0x4e, 0x1d, 0x46, 0xc2, 0xd3, 0xc2,
	0xec, 0xb1, 0x54, 0xfc, 0x45, 0x2a, 0xea, 0x4e, 0xa5, 0x01, 0xbc, 0x04, 0xa8, 0xd5, 0xc0, 0x75,
	0x69, 0x7a, 0x8f, 0xd9, 0xa1, 0x55, 0xcc, 0x8d, 0x49, 0xc6, 0x4f, 0x57, 0x30, 0x93, 0x7d, 0x35,
	0x08, 0x29, 0xe8, 0x8c, 0x91, 0xd0, 0xbf, 0x77, 0x6b, 0xae, 0x8e, 0xb2, 0xf8, 0xb3, 0x37, 0x0f,
	0x70, 0x96, 0x99, 0xd3, 0x76, 0x5c, 0x88, 0xae, 0x6f, 0x10, 0xc0, 0xdb, 0xe6, 0x87, 0x7d, 0x7a,
	0x08, 0x4e, 0x70, 0x0e, 0xee, 0x53, 0x94, 0x6d, 0x92, 0x80, 0xa0, 0x0f, 0xce, 0x3e, 0x7a, 0x4c,
	0x03, 0x0b, 0x29, 0x2c, 0xe2, 0x68, 0xb5, 0x4a, 0xcb, 0x2c, 0x5d, 0x47, 0xf1, 0x73, 0xb9, 0xcb,
	0xf3, 0x6c, 0xb3, 0x5d, 0x07, 0xf6, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf3, 0x92, 0x62, 0xa7,
	0x39, 0x01, 0x00, 0x00,
}
